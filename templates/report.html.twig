{% extends "base.html.twig" %}

{% block title %}Redovisning{% endblock %}

{% block header %}Redovisningstexter{% endblock %}

{% block main %}
    <h2 id="kmom01">Kmom01</h2>
    <p>Första gången jag kom i kontakt med objektorienterad programmering var i kursen oopython som jag läste precis innan denna kursen. Man fick ju börja känna på objekt i slutet av javascript-kursen, och att det har varit ett bra upplägg i de kurserna fram till denna. Så det är mina tidigare erfarenheter till objektorientering, och därmed även mina förkunskaper som sträcker sig till det som vi har fått lära oss i de kurserna (framförallt oopython).</p>
    <p>För att skapa sina egna klasser bör man först få en förståelse för vad ett objekt är, att det har medlemsvariabler (properties) och metoder som kapslas in inuti objektet och kan ge objektet ett visst state (läge). Medlemsvariablerna och metoderna kan vara publika eller privata, vilket gör att man kan styra användares möjligheter till hur objektet kan användas. Man skapar ett objekt från en klass som kan ses som en mall/ritning över hur varje objekt skall fungera, och objektet ses som en instans av klassen. Syntaxmässigt använder man sig utav nyckelordet "class" följt av ett klassnamn och måsvingar { } för att skapa en klass, där man lägger medlemsvariablerna och metoderna inom måsvingarna. Och för att sedan skapa ett objekt från klassen tilldelar man en variabel en instans av klassen genom att använda sig utav nyckelordet “new” följt utav klassnamnet.</p>
    <p>Kodstrukturen för uppgiften och användandet av symfony kan jag ju endast jämföra med tidigare erfarenhet av liknande mvc-strukturer vi haft i andra kurser, där jag upplever kodbasen och strukturen i php lite mindre översiktligt. Jag upplever att i andra kodspråk blir det mycket tydligare, men det har nog mest att göra med hur syntaxen är, t ex i python eller javascript. Skulle jag inte haft den tidigare erfarenheten så hade jag nog tyckt att det varit mycket svårare att greppa helheten, men tack vare tidigare erfarenhet så tycker jag ändå att strukturen och kodbasen är lättare att förstå. Då det var en stund sedan vi hade php som grund i någon av kurserna, så tycker jag att syntaxen i koden är lite ovan men det är något man kommer in i snart igen.</p>
    <p>En av de stora saker jag tar med mig från artikeln “PHP the right way” är först hur mångsidigt PHP är som programmeringspråk, något som jag har förstått först nu när efter alla de kurser som man tagit under första läsåret. Många av delarna i artikeln är intressanta och vissa delar känns igen från tidigare kurser (speciellt oopython). Särskilt intressanta kapitel var bland annat “Dependency Injections”, där jag ser för mig att om man lär sig strukturera sin kod på ett genomtänkt sätt verkligen kan underlätta för framtida underhåll och uppgradering. En annan del som jag ser som värdefull är delen om “Internationalization and Localization” för framtida utveckling till flera språk, även om jag inte helt upplevde att jag greppade i artikeln hur man skall göra rent praktiskt. Men den mest intressanta och värdefulla delen var nog den om “Security”, då det är något som jag känner jag vill veta mer om då det verkligen är viktigt att hindra någon från att försöka förstöra det man skapat.</p>
    <p>Det var mycket ny information i detta kursmomentet, men det var nog framförallt i de olika artiklarna snarare än vad vi gjorde i övningen eller för uppgiften. Det som nog var kändes helt nytt var just det jag nämnde ovan med “Dependency injections” och hur man kan tänka för att skapa en mer lättunderhållen och inte en för  “inmålad” kodstruktur. Sedan om man har lärt sig det är kanske en annan sak, man har ju inte riktigt det fått prova det i praktiken ännu men det har i alla fall tagits upp på ett sätt jag inte känner igen från tidigare erfarenheter/kurser.</p>
    
    <h2 id="kmom02">Kmom02</h2>
    <p>När man programmerar objektorienterat kan man använda sig av konstruktioner som arv, komposition, interface och trait i php. Arv fungerar som så att om man skapar en klass, och vill sedan utöka den klassen med mer funktionalitet så utan att ändra det som man kan kalla för en basklass. Då passar det med arv som då som namnet antyder ärver alla medlemsvariabler och metoder från basklassen, som man sedan kan utöka i en subklass och även skriva över existerande metoder och variabler. Vill man även komma åt all funktionalitet som är i basklassen bör man även se till att medlemsvariabler och metoder i basklassen inte är satta som private utan istället som protected eller public så att man även når dem i subklassen.</p>
    <p>En komposition är relationen mellan två klasser, där man kan tänka i uttrycket “har-en” eller “has-a” för att mellan klasserna. Man pratar om två typer av komposition beroende på hur starka de är, där en komposition är den starkaste och en aggregation en svagare relation. T ex så har ett hus rum, men rummen kan inte existera utan ett hus och är då en komposition. Däremot så kan en postlåda tillhöra ett hus, men även om huset skulle försvinna så skulle postlådan finnas kvar och är i detta exempel en aggregation. En komposition är att föredra före arv, då detta kan skapa onödigt krångliga arvskonstruktioner.</p>
    <p>Ett interface är som en abstrakt mall för hur en klass ska se ut. Ett interface bestämmer på så sätt vad som ska finnas i en klass i form av metoder, men däremot inte hur de implementeras. T ex kan man i ett interface bestämma att en klass ska ha en metod getValue() som returnerar en integer, men exakt hur detta görs och vilket värde som returneras är upp till klassen som använder sig av interfacet.</p>
    <p>Ett trait kan man se som en bit kod som man vill återanvända i flera klasser där arv inte är ett alternativ, t ex att man önskar ärva av flera från flera olika basklasser som inte är möjligt i php. En klass använder sig (nycklord “use”) av en trait, som blir som att importera den funktionalitet som finns i en trait, som man då även kan återanvända till flera klasser.</p>
    <p>Uppgiften är jag överlag nöjd med hur jag har löst, jag skapade först en min Card-klass som jag jobbade med ihop med klassen DeckOfCards för att bygga upp grunden till hur allt skulle fungera ihop. Jag såg först till att ha all funktionalitet på plats på enklast möjliga sätt, för att därefter bygga vidare med de metoder jag implementerat och göra allt lite snyggare visuellt och även renare kodmässigt. I min DeckOfCards-klass så ser jag till att ha alla korten uppdelade i tre medlemsvariabler, där jag startar med alla korten i den ena variabeln men förflyttar de till de andra när man drar ett kort eller delar ut ett kort, på så sätt har man alltid tillgång till hela kortleken. Jag har använt mig utav “injection” för att göra DeckOfCards mer flexibel, men kan göras ännu mer flexibel om man skulle använda sig av ett interface. För att visa upp en sorterad kortlek så har jag en metod som sätter ihop de tre variablerna, och sedan returnerar en komplett sorterad kortlek så jag endast jobbar med en kortlek hela tiden men som samtidigt behåller sitt state av dragna eller utdelade kort.</p>
    <p>I mina controllers så har jag en POST init-route både för /card och /api routes:en, som endast kallar på vid behov. Jag har alltså en kontroll i de olika routes:en som kollar om en sessionvariabel är satt ('card_deck' eller 'card_deck_api'), och är den inte det så skickas man till init-routen och sedan tillbaka till den route man först försökte nå. Här satt jag fast en stund för att få detta att funka för min api-route då vi skulle använda POST, men lyckades tillslut när jag insåg man behövde använda forward() istället för redirectToRoute(). Har även testat att nå mina api:er via verktyget postman, och även det fungerar som tänkt. Med lite javascript har jag även fått dem att fungera på webbplatsen, speciellt för de två draw/:number och /deal/:players/:cards så de fungerar med ett formulär på ett smidigt sätt genom att uppdatera url-en som ska användas när man ändrar i formuläret.</p>
    <p>Som förbättringspotential ser jag att lägga till att en DeckOfCard tar ett interface istället för en Card-klass när man lägger till kort, vilket hade gjort den mer flexibel för andra typer av kortlekar. CardHand behöver utvecklas mer för ett faktiskt spel, och även hur CardHand och DeckOfCards interagerar med varandra när man spelar ett kortspel där en CardHand lämar tillbaka kort till DeckOfCards. En Player-class hade nog varit bra att ha, men tänkte jag låter det vara till nästa kursmoment samt en metod för att få ur JSON-data från klasser. Koden kan nog snyggas till och göras tydligare överlag, även med lite mer kommentarer för att förtydliga, men jag är rätt så nöjd med hur jag har löst uppgiften.</p>
    <p>Ang punkten “Berätta hur det kändes att modellera ett kortspel med flödesdiagram och psuedokod. Var det något som du tror stödjer dig i din problemlösning och tankearbete för att strukturera koden kring en applikation?” så förstår jag inte helt vad som menas, det känns som att detta är en kvarleva från en tidigare version.</p>
    <p>Mycket nytt som vanligt i detta kursmomentet, men det jag lärde mig mest utav var hur man kunde styra om en användare även när man skulle nå POST delar av sin webbplats. Som jag nämnt ovan satt jag länge med detta innan jag förstod hur man kunde göra, men det var lärorikt.<p>
    
    <h2 id="kmom03">Kmom03</h2>
    <p>Att försöka lösa det/de problem som uppgiften hade med flödesdiagram och psuedokod hade både sina för- och nackdelar. Flödesdiagramet tyckte jag hjälpte mig att få en uppfattning av hur hela kortspelet skulle fungera i stora drag, vilket också hjälpte att få fram en tanke om hur koden kunde struktureras och även som en påminnelse när man väl hade börjat implementera själva spelet. Psuedokoden däremot tyckte jag var svårare att få till, och den jag gjorde förklarar mer eller mindre också samma sak som flödesdiagrammet. Jag behöver bli bättre på att tänka igenom saker mer innan jag startar för det kan lätt bli lite lösningar längs vägen, men samtidigt har jag svårt att visualisera vad exakt som kan behövas och det blir lätt att jag låser mig i tankeprocessen istället för att komma igång. Att försöka skriva delar i psuedokod tyckte jag låste mig ännu mer och kände att i alla fall denna gången snarare bromsade mig mer än vad den hjälpte. Men när jag byggde vidare på spelet och skulle lägga till möjligheten att “splitta” en korthand, då var det mycket mer hjälpsamt att kunna tänka hur man skulle lösa det, men då hade jag ju också existerande kod att utgå ifrån.</p>
    <p>För att lösa uppgiften valde jag att göra blackjack istället för 21, och där ville jag fortsätta jobba med att injecta kort i en kortlek, mest för att få in vanan och se hur man kan göra snarare än att det egentligen kändes nödvändigt. Så bland de klasser jag skapade för uppgiften skapade jag även en DeckFactory för just detta ändamålet. De andra klasserna som jag sedan skapade kan man se på min <a href="{{ path('blackjack_doc') }}">/game/doc</a> sida, men jag försökte skapa klasser som hade sin egen roll/funktion där man sedan jobbade endast mot själva GameBlackjack-klassen i controllern för spelet. Andra klasser som används i spelet förutom själva korten skapar jag däremot i GameBlackjack då det blir en rätt så direkt koppling mellan t ex regler och spelet där såg jag ingen anledning till att göra det mer flexibelt med injections. I min RulesBlackjack-klass har jag några publika metoder, där en av dem returnerar en associative array med data som kan användas för vilka val som kan presenteras för spelaren. Tanken här var att jag först gjorde ett spel som uppfyllde kraven, men som sedan kunde byggas på med mer regler som används i blackjack (ex split och double-down) som jag såg för mig krävde lite mer tid, och som då bara kunde läggas till i arrayen och sedan jobbas vidare med utan att behöva ändra allt för mycket den andra koden. När jag sedan la till split kunde jag behålla mycket av koden som den var, men jag behövde ändra om i metoderna då en spelare nu kunde ha flera händer och en runda var inte bank mot spelare utan bankens hand mot alla spelarens händer t ex.</p>
    <p>Koden i sig är jag ok nöjd med skulle jag säga, det känns som jag kunde tänkt igenom upplägget mer och på så sätt eventuellt kunnat gjort en mer genomtänkt lösning. Tanken var ju att vi skulle hålla det enkelt, och det har jag ju ändå försökt att göra men det känns som det finns mycket enklare och kanske bättre sätt få en klass att göra samma sak som det jag har gjort. Jag valde ju att göra blackjack istället för 21 just för att det är lite andra regler som rimligtvis kräver lite mer kod och en lite större utmaning, så någonstans får man väl samtidigt tänka att “better done than perfect”. Koden växte mer direkt när det blev möjligt för en spelare att ha flera korthänder efter en split, vilket även gjorde spel-logiken annorlunda när varje runda kunde spelas mot 1 till 4 händer snarare än 1 mot 1. Som koden är vid inlämning är banken endast en korthands-klass och inte en spelar-klass, vilket behöver ändras om banken ska ha begränsat med pengar t ex, men har låtit detta var för nu då banken endast spelar med en hand och mycket utav funktionalitet i spelar-klassen är för att kunna hålla flera händer. Sen kan koden nog städas upp mer i allmänhet och få lite mer kommentarer för att förtydliga hur den fungerar.</p>
    <p>Så långt in i kursen tycker jag det har känts rätt bra att jobba med symfony då jag tycker att tack vare övningarna förstått hur man kan använda sig av det utan att det känns krånligt på något sätt. Det största hindret i starten av kursen var snarare att uppdatera kunskapen för syntaxen i php snarare än att förstå ramverket, så det är absolut en positiv känsla för symfony. En sak som jag tyckte var speciellt bra under detta kursmomentet som kanske inte nödvändigtvis har direkt med symfony att göra, var att vi fick tydlig info om var man ska placera sin kod. I förra det kursmomentet så var jag nöjd med hur jag löst uppgiften, men hur koden var skriven och placerad kändes varken helt bra eller speciellt “snyggt”. Så det första jag gjorde var att städa upp förra kursmomentets controller så att det blev lite renare och tydligare.</p>
    <p>Som vanligt i alla kursmoment är det mycket nytt, men det som stack ut denna gången och gav mig var det som jag nämnde ovan om hur man kan/ska tänka när man placerar ut sin kod och vart den ska vara. Jag har tidigare tänkt lite mer att det är "onödigt" att ha mer klasser än nödvändigt, men efter detta kursmomentet blev det tydligt att det blir ju faktiskt mycket tydligare och “snyggare” om man har mer klasser som har sina uppgifter, vilket underlättar mycket att hålla nere koden man har i en controller utöver att skapa en tydligare struktur i sin kod.</p>
    
    <h2 id="kmom04">Kmom04</h2>
    <p>Att använda sig av PHPunit har under kursmomentet känts bra och fungerat utan några större bekymmer. Då jag fick prova på att skriva enhetstester i OOPython kursen så har man ju fått lite tidigare erfarenhet av hur man kan skriva tester, och det i sin tur har nog hjälpt en hel del till att känna sig någorlunda bekväm med upplägget. PHPunit i sig tycker jag verkar vara ett smidigt verktyg för att testa sin kod, och även om man bara skrapat på ytan av dess potential så ser jag hur det kan förenkla mycket även på det sättet jag har använt det i kursmomentet.</p>
    <p>Bortsett från mina controllers så uppnådde jag en kodtäckning av 100%, men det är en del kod som i vissa klasser “kommer på köpet” när man testar en publika metod, så även om det är en hög kodtäckning så är inte all kod utförligt testad. Vissa klasser var lättare att testa än andra, vilket ju var väntat med tanke på hur vissa klasser är mer fristående från andra och att t ex min GameBlackjack klass är beroende av alla andra klasser för att fungera. På så sätt så upplevde jag delar av min kod som enklare att testa, som t ex mina kortklasser eller min korthands-klass. Men ju mer beroende en klass var av andra klasser, desto svårare blev det att skriva bra test, där som nämnt att min GameBlackjack-klass blev lite omständig att testa även om jag fick till en hög kodtäckning. Jag har under utvecklingen av spelet tyckt att koden i sig blev lite för omständig, och det blev ännu tydligare nu när man skulle skriva tester att jag placerat olika funktioner/delar på mindre genomtänkta ställen.</p>
    <p>Jag behövde inte skriva om koden speciellt mycket för att kunna testa den, det enda jag egentligen gjorde var att ändra om lite i min Card-klass för att få metoden getAsString lite bättre skriven. Och sedan ändrade jag så att i min GameBlackjack-klass att man behövde injecta en kortlek till spelet, vilket i sig gjorde att jag kunde styra lite mer vilka kort jag gjorde mina test med. Jag hade däremot lust att göra om mycket av koden för att få den bättre skriven i allmänhet, men det skulle bli ett mycket större projekt än vad jag tyckte det vore rimligt att lägga tid på så jag får hellre se det som en lärdom till framtiden. Jag har gjort lite för mycket enkla "små lösningar" längs vägen som i slutändan har gjort allt lite krångligare att jobba med och framförallt att testa.</p>
    <p>Att kod som är förhållandevis smidig eller “enkel” att testa skulle jag efter detta kursmomentet anse även kunna passa i kategorin “snygg och ren kod”. Som nämnt ovan så var ju vissa delar av min kod lättare att testa, och i de klasserna har jag även tyckt att jag har lite bättre strukturerad kod. Och att i de klasser som varit lite mer omständiga att testa så har jag inte varit helt nöjd med hur jag skrivit min kod, vilket ju inte gör att det riktigt kan beskrivas som varken “snygg” eller “ren” kod. Hade man haft med sig mindsetet att bra kod är enkel att testa när man skrev koden till spelet, så hade jag nog tänkt mer på hur jag hade strukturerat upp spelet. Men det har varit lärorikt att få jobba med sin egen mindre bra kod, och få se hur det verkligen kan bli lite svårare att testa och jobba med den än att bara ha läst sig till den kunskapen. Kan här också nämna att jag har provat lite olika sätt när klasser använder sig av andra klasser i mina tester, där jag ibland har skapat de objekt instanser av de klasser som behövs och ibland har jag gjort mocks eller stubs istället.</p>
    <p>Som så många andra kursmoment så var det mycket att ta in även denna gång. Att skriva själva enhetstesten eller att dokumentera sin kod var inte främmande då jag gjorde liknande i kursen OOpython med tester och dokumentation av sin kod i kursen JS. Det som blev en liten ögonöppnare däremot var just det med hur mycket svårare det blir att testa kod som är mindre bra skriven, och hur mycket mer kod som behövs för att testa sån kod. Jag har nämnt i tidigare redovisningstexter både i denna kursen och i andra att jag behöver bli bättre på att tänka igenom hur jag ska lösa något, och nu blev det ännu tydligare hur viktigt det är. Det är lite som att när jag börjar se “målsnöret” och närma sig något som fungerar, så blir det lite för mycket provisoriska lösningar som fixar ett eller annat problem, vilket sen har gjort koden lite för otydlig och ostrukturerad.</p>
    
    <h2 id="kmom05">Kmom05</h2>
    <p>Övningen för att komma igång med Symfony och Doctrine i detta kursmomentet har gått bra. Jag stötte inte på några direkta problem utan det flöt på och den, precis som många andra övningar, var lätt att följa och att förstå. Det var ingenting som jag direkt reagerade extra på men däremot så upplevde jag det väldigt enkelt och användarvänligt, inte bara övningen i sig utan även hur man kunde jobba med doctrine och skapa entiteter i databasen. I både övningen och i uppgiften har jag jobbat med sqlite som jag tycker är ett väldigt smidigt och enkelt sätt, och även om det vore lärorikt att även sätta upp så man kunde jobba mot ytterligare en databas som MariaDb så lät jag det vara för nu.</p>
    <p>Så som jag la upp biblioteket på min sida så visar jag alla böcker på landningssidan med bild och titel, där bokens författare och länk till bokens egen sida visades om man drog musen över boken. Lät även bilden på boken i sig vara klickbar för att fungera på en mobil enhet. Man kan via en länk välja att lägga till ytterligare en bok, eller att gå in på någon av de enskilda böckerna som finns i databasen. När man sedan är inne på en enskild bok kan man välja att uppdatera infon eller ta bort den från databasen. Jag la till länkar så att man alltid kunde gå tillbaka till routen man kom ifrån när man t ex klickade sig in på en enskild bok, för att få en bättre användarupplevelse. Det man kanske kunde gjort är också att ha någon form av bekräftelse eller extra route när man ville ta bort en bok så att man inte råkade klicka fel, men lät detta vara då jag inte såg det som ett stort problem.</p>
    <p>Att jobba med ORM har jag under kursmomentet tyckt vara ett riktigt smidigt och enkelt sätt att jobba mot en databas. Alla delar i CRUD tyckte jag var enkelt att implementera och även det gränssnitt som man själv får jobba emot. De funktioner som krävdes för detta kursmoment var ju alla en del av strukturen och gränssnittet som man kunde använda sig av. För API:et där man skulle söka efter något annat än själva id:et var ju väldigt smidigt då metoden redan fanns t ex. Något annat jag tänkte på var däremot hur de filer som skapades inte gick igenom phpmd valideringen, så där valde jag att exkludera de filerna det gällde från valideringen.</p>
    <p>Det lilla jag har använt mig av ORM hittills i detta kursmomentet så är min uppfattning att det verkar vara ett väldigt smidigt sätt att jobba mot en databas. Man fick ju jobba en del mer direkt mot databasen i databas-kursen, så jämfört med det var det rätt så enkelt med det gränssnitt som doctrine gav. Att ha ett lager som gör att man kan jobba mot olika typer av databaser gör ju att det blir enklare att nyttja olika databasernas potential, beroende på vad man nu vill göra, utan att det behöver bli mycket mer kod i sin applikation.</p>
    <p>Nytt för detta kursmoment var vad ORM är för något och hur det kan användas. När man läste igenom “PHP the right way”, speciellt avsnittet om injections, blev man ju introducerad av idén att jobba mer mot ett abstrakt lager/interface. Redan där så gick det upp att detta kan ju göra jobb mot bl a olika databaser lättare, och att det nu i detta kursmomentet även blev tydligt hur man kan jobba med det.</p>

    <h2 id="kmom06">Kmom06</h2>
    <p>PhpMetrics upplevde jag under kursmomentet som ett bra verktyg för att få lite hårda mätvärden på sin kod. Däremot så har jag tyckt att läsa själva rapporten har varit lite svårt, då man inte har varken vanan eller kunskapen till att riktigt analysera vad man får för data. Det gjorde i sin tur att man hade lite svårt att sålla ut vad som är mest relevant, och även svårt att få en helhetsbild av hur all data hänger ihop. Det som jag ser som mest värdefullt är nog violations, complexity och maintainability index där de två sistnämnda kan vara en bra indikator på hur svår koden kan vara att utveckla och jobba vidare med. Tycker även att de stämde bra överens på hur jag själv har upplevt min kod inför detta kursmomentet, så det blev lite av en bekräftelse på det.</p>
    <p>När jag försökte få scrutinizer att interagera med mitt eget repo stötte jag på lite problem i starten. Jag började med detta före tisdags-zoomen, och därmed hade jag inte den uppdaterade config-filen så det tog lite längre tid att felsöka varför den inte klarade att bygga mitt repo. Detta var väl i sig lärorikt, alltid bra när man klarar att lösa problem själv, men det tog lite mer tid än önskat att lösa problemet men hade ju gått fortare om man inväntade den uppdaterade config-filen. När jag tillslut fick min kod att gå igenom så fick jag 9.95 som betyg på kodkvalitén och 54 % i kodtäckning. Jag blev lite överraskad att jag fick så pass högt betyg, det hade jag inte väntat mig då jag inte varit helt nöjd med koden. Däremot så har jag försökt hålla nere komplexiteten i mina metoder, vilket ju förmodligen också visade sig i betyget. Även om det är ett smidigt verktyg som kan ge ett hum om kodens kvalité, så behöver man nog sätta sig mer in i koden då min uppfattning är att det är mycket som ligger bakom betyget. Baserat på den koden jag har använt som jag känner till, upplever jag att scrutinizer och dess badges är bra på att visa kvalitén på mindre delar i koden men att den inte riktigt klarar att visa upp helhetsintrycket. Jag tycker inte att betyget 9.95 är helt rimligt på det koden jag har gjort, men kan se hur det kan stämma om man ser det mer på metod-nivå. Jag tycker ändå att verktyget är bra, men att man får ta det för vad det är och inte se allt för mycket på helhetsbetyget.</p>
    <p>Kodkvalitet tycker jag definitivt är viktigt, och alla verktyg som gör att man kan förbättra sin kod på olika sätt är bra. Samtidigt blir det mycket att sätta sig in i om man använder allt för många verktyg, så jag kan tänka mig att det är bättre att hitta några bra verktyg som man lär sig och tolka mätvärden från istället för att ha många med enkla och tydliga betyg. Med enkla betyg menar jag här t ex badges från scrutinizer, då de ju är just enkla att titta på med sina färgkoder och hårda värden, men det är mycket som gömmer sig bakom värdena. PhpMetrics är här bättre tycker jag, men man behöver få mer förståelse för vad man faktiskt tittar efter då det är mycket data som presenteras för en. Att lära sig dessa eller liknande verktyg tror jag definitivt kan hjälpa en att skriva renare och bättre kod. Jag tror att i många fall kan badges och sammanfattade betyg ge en indikation på kodens kvalitet, men att man behöver vara medveten om att t ex vissa delar kanske måste vara komplexa för att nå dit man vill. I slutändan så säger ju alla dessa värden inte vad koden faktiskt gör eller fungerar, utan mer hur den är skriven. </p>
    <p>I detta kursmoment var det som vanligt mycket nytt, både när det kommer till de verktyg som använts och olika begrepp. Ska jag välja något så är det hur man automatiskt kan testa sin kod med verktyg som scrutinizer. Jobbar man flera på ett projekt så är det ju väldigt smidigt att jobba mot ett repo där alla enkelt kan se när och varför saker har ändrats, och ännu bättre om man även kan få koden testad samtidigt. En annan sak som var nytt är hur mycket av sin kod som man kan mäta och sätta något betyg på. Via PhpMetrics blir det nästan ett överflöd av mätvärden, som jag ser för mig kan hjälpa till mycket när man vill förbättra sin kod så länge man vet vad man tittar efter. </p>
    
    
    <h2 id="kmom07-10">Kmom07/10</h2>
    <h4>Krav 1-3</h4>
    <p>För projektet valde jag att göra ett äventyrsspel likt ett escape-room, där man kan klicka sig runt för att hitta olika ledtrådar för att hitta vägen ut ur det hus som man är inlåst i. På min report-sida har jag använt bootstrap för att förenkla stilen, vilket jag även gjort för projektet men har skrivit desto mer css-kod själv för att styla sidan mer som jag ville men bootstrap ligger fortfarande som grund. Jag valde en mörkare stil och jobbade med vit och grön som kontrastfärger för att ge det lite av enkel men lite neonlysande stil.</p>
    <p>För att göra en ny sida så skapade jag en egen mapp till projektet, där jag valde att lägga en ny base.html.twig-fil som jag använde som min nya bas för alla sidor i projektet. Har sedan olika templates och routes för olika delar av spelet, som till exempel om man vill titta närmare på ett av spelets objekt eller titta i ryggsäcken där man kan lägga saker man hittar i de olika rummen. Repot är uppdaterat med en README fil där det finns en punktlista över hur man kan installera repot lokalt, länkar och bild till scrutinizers badges samt lite allmän information om repot. Mappen docs/ är även uppdaterad och uppladdad på repot och innehåller dokumentationen om kodtäckningen, phpmetrics samt phpdoc. För alla klasser som används i själva spelet så har jag en kodtäckning på 100% borträknat controllers och databasen, men där även de har en viss kodtäckning om än mycket lägre.</p>
    <p>För själva spelet i sig så valde jag att redan från start jobba mot en databas för att hämta data om rummen, hur man kan röra sig i rummen samt vilka objekt som finns i respektive rum och hur man kan interagera med dem. Här var min tanke att man skulle enkelt kunna lägga till eller ändra saker i databasen och att rummen sedan uppdaterades därefter. Målet var här att ha en sådan struktur att man enkelt skulle kunna bygga vidare med flera rum, eller helt nya rum och kunna ha flera olika småspel genom att lägga till mer data i databasen. Här nådde jag inte riktigt fram till hur jag hade tänkt att det skulle fungera då vissa saker tog längre tid än tänkt utan fick ändå hårdkoda vissa delar, vilket inte påverkar detta spelet men vill man bygga vidare behövs det lite mer arbete med vissa delar av koden.</p>
    <p>Jag har skapat en del klasser för spelet för att dela upp koden i mindre delar, och försöka använda mycket injections för att låta varje klass vara mer självständig och därmed enklare att testa. Under utvecklingen har jag använt mig mycket av linters och metrics, vilket har varit ett väldigt hjälpsamt verktyg för att inte göra allt för komplex kod. De mest komplexa klasserna är de som är till för att initiera spelet och spela själva spelet, vilket är rimligt då de ändå blir beroende av andra klasser för att fungera som tänkt. Även här har jag försökt att dela upp i ännu fler filer för att till exempel initiera de olika rummen eller objekten i en egen klass för att sedan injecta dem i själva spel-klassen.</p>
    <p>De handlingar eller “actions” man kan göra i spelet utgår från ett interface, där tanken var att låta alla olika handlingar vara en egen klass och utgå från en viss struktur så att man enklare skulle kunna injecta vilken handling som helst i ett objekt. Med facit i hand hade det kanske varit bättre att istället ha en basklass som man sedan hade ärvt ifrån då de “actions” som man kunde göra behövde lika olika struktur för att fungera som tänkt. Fick därför skapa fler interfaces som ärvde från det första interfacet för att uppnå målet som jag hade, vilket i sig kanske inte gör så mycket mer än att det blev lite mer filer än nödvändigt. Däremot så tror jag ändå att den typen av struktur med interfaces är bättre om man skulle bygga vidare och lägga till fler actions.</p>
    <p>För att klicka sig runt i spelet använder jag mig av transparenta formulär, som har fått storlek och position från databasen och som sedan placeras ut med procentenheter. Detta har jag gjort för att låta spelet bli responsivt, så det kan fungera på en mobil enhet även om jag anser det blir som bäst på en desktop eller åtminstone en surfplatta med lite större skärm. Alla bilder har jag hämtat från openclipart.com och clikr.com och vid behov redigerat dem. </p>

    <h4>Krav 4</h4>
    <p>För krav fyra så skapade jag fem stycken olika API:er, som alla finns under /proj/api där fyra använder sig av metoden GET och ett av metoden POST. För att välja vilken data som skulle hämtas till de olika API:erna så utgick jag ifrån vad för data jag behövde för att kunna visa upp spelet i webbläsaren. Med mina GET API:er kan man hämta ut data om alla objekt i spelet, alla förflyttningar i spelet, data om ett rum baserat på id och även data om ett objekt baserat på id. I mitt POST API så kan man hämta data om ett rum tillsammans med vilka objekt som finns i det rummet. När jag först hade ett fungerande spel så hade jag endast en GameInitializer-klass, men detta gav lite problem när jag skulle skapa API:erna och hämta ut den data jag ville från databasen. Så i samband med att jag valde API:er så delade jag även upp min initierar-klass så att jag hade flera olika klasser som initierade olika delar i spelet, vilket jag då sen även kunde använda mig av för att hämta ut data till  mina API:er. Detta gjorde ju även GameInitializer-klass mindre komplex vilket även gav den ett bättre maintainability-index i php-metrics. Jag har även skrivit enhetstester för min controller till API:erna för att se att de fungerar som tänkt, samt att de hämtar den data som förväntas från databasen.</p>
    
    <h4>Krav 5</h4>
    <p>Redan vid starten valde jag att låta databasen vara en del av hur jag skulle hämta ut data för att kunna initiera alla spelets instanser. Då Doctrine redan var installerat sedan tidigare kursmoment så var det ju förhållandevis enkelt att lägga till nya entiteter i databasen. Till projektet hämtar jag endast data från databasen, då jag inte sett att det varit behov för att uppdatera eller skriva till den för detta projekt. Däremot om man skulle lägga till fler rum/objekt skulle ett formulär fungera som ett enkelt gränssnitt för det. Datan som jag la in i databasen läste jag in via en insert.sql fil, vilket jag tycker är tillräckligt smidigt för ändamålet. Datan hämtas bara ut en gång när man initierar spelet, vilket är för att låta varje spel-klass inte vara beroende av databasen när väl spelet är igång. Om man bortser från de klasser som initierar instanserna, så är klasserna till spelet i sig egentligen inte beroende av databasen men däremot så behövs ju den datan som krävs hämtas någonstans ifrån. Hade man inte haft databasen hade man alltså kunnat lägga in det data som spelet krävde på något annat sätt.</p>
    <p>Hur spelet blev i slutändan skiljde sig ifrån hur jag hade tänkt att det skulle bli från början, då synen på hur man skulle göra vissa delar förändrades något allt eftersom och därmed även datan i databasen. Detta i sig gjorde att jag fick göra en del förändringar med migrations, vilket jag i stunder upplevde som tidskrävande på grund av ovanan med Doctrine. Jag har ändå försökt att göra allt via migrations, men för att lägga till främmande nycklar så fick jag manuellt lägga till SQL-kod i några av mina migrations för att få till den kopplingen som jag ville ha. Databasen innehåller totalt fyra olika tabeller där de förhållanden som finns är av typen en-till-många.</p>
    <p>För att få databasen att fungera för scrutinizer eller om man laddade ner repot lokalt, så gjorde jag helt enkelt så att när man kör kommandot composer install så kopierar även det databasen från mappen /db in till /var och så att den är med från start. Detta har gjort att jag även klarat att köra tester som hämtar data från databasen via scrutinizer. Man kan även återställa databasen på webbplatsen om det inte fungerar av någon anledning, det gör man längst ned på sidan man kan läsa om databasen (/proj/about/database). En backup-SQL fil läses då in och återställer databasen, och jag är här medveten om att filen ligger i min public/ mapp vilket kan ge en risk att utifrån enklare manipulera databasen.</p>

    <h4>Krav 6</h4>
    <p>Så som jag har lagt upp min applikation, så har tanken varit att detta ska man kunna bygga vidare på och relativt enkelt lägga till fler rum med dess objekt genom att uppdatera i databasen. Det tog en stund att komma fram till hur jag skulle lägga upp koden för det, men när det väl var på plats så var det väldigt smidigt att bara uppdatera databasen med objekt och dess data så hamnade det på önskad plats i rummen. Och även om jag inte helt nådde dit jag ville på grund av tiden (det är ju trots allt begränsat hur mycket man hinner göra på 40 timmar) så är ändå den största grunden för detta lagd i min kod.</p>
    <p>Då jag har använt mig av procent för att placera ut de olika objekten på sidan, så fungerar spelet på mobila enheter även om det finns lite mer att önska i själva designen. Detta är såsom jag tolkat inte en del av något krav, varken baskrav eller optionellt, och har tagit lite extra tid för att få till men något som är värt att få in anser jag. Jag har också lagt ner lite tid på att få spelet att ha en någorlunda bra användarupplevelse som flyter på, i alla fall så mycket man kan få det att flyta på när varje förändring sker via en request till servern. Att ha en webbplats som även fungerar på mobila enheter anser jag vara viktigt för användarvänligheten, även om det inte varit en del av kraven. Har också lagt till lite flödeskontroll så om man försöker gå in direkt på /proj/game för att spela utan att ha initierat ett spel så skickas man tillbaka till startsidan för att förhindra att sidan kraschar.</p>
    <p>Att få mina enhetstester som jobbar mot databasen att fungera även via scrutinizer var något som även det tog en del tid att förstå hur man kunde lösa. Detta gick upp för mig först när jag testade klona repot och då insåg jag lite mer vad som faktiskt görs när scrutinizer laddar hem och installerar repot. Som nämnt i krav 5 så löstes detta med att låta ett kopiera databasen med ett sista kommando när man körde composer install. I samband med det så kan jag ju nämna att jag har en total kodtäckning på 75% inkluderat alla klasser de klasser som finns i min src/.</p>
    <p>Tanken med mina JSON-routes var att jag skulle ersätta att använda getters för att hämta ut den data som behövdes för vyerna. Detta för att ha ett ännu tydligare gränssnitt däremellan så att den data som behövdes endast kom i form av ett JSON-objekt. Men även här på grund av tiden så har jag inte hunnit att göra den förändringen, detta hade minskat behovet av getters och att ha mindre metoder i flera av klasserna. Och hade jag börjat med det så skulle även testerna behöva uppdateras då flera metoder kunde plockas bort, men jag hade helt enkelt inte tid med det.</p>
    <p>Som sista punkt kan jag nämna att även om det inte har med detta projektet att göra i sig, så gjorde jag ju redan i kmom03 ett blackjack-spel istället för 21 där man t ex kan spela med flera händer när/om man splittar sin hand. Tyckte att det var värt att nämna då det ju faktiskt var möjligt att välja som ett av projekten.</p>

    <h4>Allmänt om projektet</h4>
    <p>Projektet som helhet har varit kul att göra, men det har varit tidskrävande av flera anledningar. Det blir mycket som ska hinnas med på 40 timmar om man ska gå från att få fram en idé till ett spel som sedan ska fungera både i kod och visuellt för en spelare. Att komma på kodstrukturen gick ändå förhållandevis bra, även om det alltid finns mer att önska, men det största problemet var tveklöst Doctrine och dess migrations. Det har varit lärorikt att jag har fått krångla med dem, men det har tagit allt för mycket tid i förhållande till dess värde för projektet. Att vilja ändra saker i eftertid i databasen via Doctrine är något som jag kommer tänka mig om i framtiden och ha en mer genomtänkt struktur från början. Jag vill sällan dela in saker i lätt eller svårt, utan hellre mer eller mindre tidskrävande och detta projektet har tagit en del tid att slutföra. Men det är man själv som sätter sina egna mål och krav, och jag tycker att projektet har varit en rimlig avslutning på denna kursen.</p>
    
    <h4>Allmänt om kursen</h4>
    <p>Kursen har som helhet tycker jag har varit bra, lärorik och en rätt så bra avslutning på det första läsåret. Har dock upplevt att det är lite varierat hur mycket tid som de olika kursmomenten kan ta, där man delvis kan känna att man hade önskat lite mer lärarledd genomgång i vissa av kursmomenten. Framförallt i de sista kursmomenten hade det inte skadat att ha mer lärarledd undervisning, och jag kan känna att det blir mycket nytt utan att kunna riktigt sålla ut vad som är viktigt att ta med sig. Som distansstudent måste man ju vara rätt så självgående, men när det blir mycket nytt att ta in med t ex manualer som referenser så har jag i alla fall upplevt att det tar lite stopp. Och ibland hade man kanske önskat att man gick lite mer på djupet i vissa delar istället för att ha med så mycket olika saker i samma kurs. Skulle nog inte rekommendera denna kursen till några vänner, utan skulle nog hellre rekommendera att gå en liknande kurs i JavaScript då det känns lite mer modernt än php som språk. Att till exempel göra spel som ju har varit en del av kursen där man jobbar mot servern i form av formulär känns inte speciellt användarvänligt då man måste ladda om sidan istället för att bygga den dynamiskt. Jag ger kursen betyget 7 av 10.</p>
{% endblock %}
